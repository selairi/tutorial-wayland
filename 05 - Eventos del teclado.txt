Capturando eventos del teclado
==============================

Ya se han capturado eventos del ratón. Para realizar la captura de eventos del teclado se procederá de una forma similar que con wl_pointer. Es decir, se capturará la interfaz wl_seat y con la siguiente función se obtendrá una instancia del objeto wl_keyboard:

    struct *wl_keyboard wl_seat_get_keyboard(struct wl_seat *wl_seat);

Después se procederá a crear un struct wl_keyboard_listener y se añadirá como escuchador:

    wl_keyboard_add_listener(struct wl_keyboard *wl_keyboard, struct wl_keyboard_listener *wl_keyboard_listener, void *datos);

Los eventos que se van a obtener son, entre otras cosas, los códigos de las teclas que se están pulsando. Cada tecla tiene asociado un código, según el mapa del teclado que se tenga configurado el usuario esa tecla que se está pulsando representará un carácter u otro. Si se pulsa una tecla y se genera el carácter 'ñ' para un teclado en codificación "es", si se cambia la codificación a otro idioma, al pulsar la misma tecla en lugar de la 'ñ', se puede generar otro símbolo. Aunque la tecla pulsada es la misma y se genere el mismo código para dicha tecla. Va a ser la aplicación cliente que se conecta al servidor wayland la encargado de procesar dichos códigos y generar los caracteres adecuados para cada tecla. 

Para el escuchador habrá que implementar la siguiente estructura:

    struct wl_keyboard_listener {
    	/**
    	 * keyboard mapping
    	 *
    	 * This event provides a file descriptor to the client which can
    	 * be memory-mapped to provide a keyboard mapping description.
    	 *
    	 * From version 7 onwards, the fd must be mapped with MAP_PRIVATE
    	 * by the recipient, as MAP_SHARED may fail.
    	 * @param format keymap format
    	 * @param fd keymap file descriptor
    	 * @param size keymap size, in bytes
    	 */
    	void (*keymap)(void *data,
    		       struct wl_keyboard *wl_keyboard,
    		       uint32_t format,
    		       int32_t fd,
    		       uint32_t size);
    	/**
    	 * enter event
    	 *
    	 * Notification that this seat's keyboard focus is on a certain
    	 * surface.
    	 *
    	 * The compositor must send the wl_keyboard.modifiers event after
    	 * this event.
    	 * @param serial serial number of the enter event
    	 * @param surface surface gaining keyboard focus
    	 * @param keys the currently pressed keys
    	 */
    	void (*enter)(void *data,
    		      struct wl_keyboard *wl_keyboard,
    		      uint32_t serial,
    		      struct wl_surface *surface,
    		      struct wl_array *keys);
    	/**
    	 * leave event
    	 *
    	 * Notification that this seat's keyboard focus is no longer on a
    	 * certain surface.
    	 *
    	 * The leave notification is sent before the enter notification for
    	 * the new focus.
    	 *
    	 * After this event client must assume that all keys, including
    	 * modifiers, are lifted and also it must stop key repeating if
    	 * there's some going on.
    	 * @param serial serial number of the leave event
    	 * @param surface surface that lost keyboard focus
    	 */
    	void (*leave)(void *data,
    		      struct wl_keyboard *wl_keyboard,
    		      uint32_t serial,
    		      struct wl_surface *surface);
    	/**
    	 * key event
    	 *
    	 * A key was pressed or released. The time argument is a
    	 * timestamp with millisecond granularity, with an undefined base.
    	 *
    	 * The key is a platform-specific key code that can be interpreted
    	 * by feeding it to the keyboard mapping (see the keymap event).
    	 *
    	 * If this event produces a change in modifiers, then the resulting
    	 * wl_keyboard.modifiers event must be sent after this event.
    	 * @param serial serial number of the key event
    	 * @param time timestamp with millisecond granularity
    	 * @param key key that produced the event
    	 * @param state physical state of the key
    	 */
    	void (*key)(void *data,
    		    struct wl_keyboard *wl_keyboard,
    		    uint32_t serial,
    		    uint32_t time,
    		    uint32_t key,
    		    uint32_t state);
    	/**
    	 * modifier and group state
    	 *
    	 * Notifies clients that the modifier and/or group state has
    	 * changed, and it should update its local state.
    	 * @param serial serial number of the modifiers event
    	 * @param mods_depressed depressed modifiers
    	 * @param mods_latched latched modifiers
    	 * @param mods_locked locked modifiers
    	 * @param group keyboard layout
    	 */
    	void (*modifiers)(void *data,
    			  struct wl_keyboard *wl_keyboard,
    			  uint32_t serial,
    			  uint32_t mods_depressed,
    			  uint32_t mods_latched,
    			  uint32_t mods_locked,
    			  uint32_t group);
    	/**
    	 * repeat rate and delay
    	 *
    	 * Informs the client about the keyboard's repeat rate and delay.
    	 *
    	 * This event is sent as soon as the wl_keyboard object has been
    	 * created, and is guaranteed to be received by the client before
    	 * any key press event.
    	 *
    	 * Negative values for either rate or delay are illegal. A rate of
    	 * zero will disable any repeating (regardless of the value of
    	 * delay).
    	 *
    	 * This event can be sent later on as well with a new value if
    	 * necessary, so clients should continue listening for the event
    	 * past the creation of wl_keyboard.
    	 * @param rate the rate of repeating keys in characters per second
    	 * @param delay delay in milliseconds since key down until repeating starts
    	 * @since 4
    	 */
    	void (*repeat_info)(void *data,
    			    struct wl_keyboard *wl_keyboard,
    			    int32_t rate,
    			    int32_t delay);
    };

Si se leen los métodos que se van a implementar en esta estructura se tendrán:

 - keymap: Se obtiene una descripción del mapa del teclado actual.
 - enter: Al igual que se tienen eventos para cuando se entrar y se sale de una ventana, también se generará un evento "enter" cuando la ventana tenga el foco del teclado. Esto se usa, por ejemplo, para dibujar el símbolo parpadeante del cursor cuando se tiene el foco para escribir.
 - leave: Se pierde el foco del teclado.
 - key: Cuando se pulsa o se deja de pulsar una tecla se va a generar un evento de este tipo. Se obtendrá el código de la tecla pulsada así como su estado, si ha sido pulsada o se ha dejado del pulsar.
 - modifiers: Modificadores de la tecla, ¿se han pulsado la mayúsculas o la tecla control?
 - repeat_info: Cuando se deja pulsada una tecla es el cliente el que se debe encargar de generar la repetición de una tecla si ésta se deja pulsada.

Por ejemplo, en una sesión de trabajo se podrían dar los siguientes eventos: 

    [wl_keyboard_listener_keymap]
    [wl_keyboard_listener_repeat_info] rate=25 delay=600
    [xdg_surface_listener_configure]
    [wl_buffer_listener_release] Buffer destruido
    [wl_keyboard_listener_enter]
    [wl_keyboard_listener_modifiers]
    [xdg_surface_listener_configure]
    [wl_keyboard_listener_key] key=28 state=0 
    [wl_buffer_listener_release] Buffer destruido
    [wl_keyboard_listener_key] key=39 state=1 
    [wl_keyboard_listener_key] key=39 state=0 
    [wl_keyboard_listener_key] key=39 state=1 
    [wl_keyboard_listener_key] key=39 state=0 
    [wl_keyboard_listener_key] key=54 state=1 
    [wl_keyboard_listener_modifiers]
    [wl_keyboard_listener_key] key=30 state=1 
    [wl_keyboard_listener_key] key=30 state=0 
    [wl_keyboard_listener_key] key=54 state=0 
    [wl_keyboard_listener_modifiers]
    [wl_keyboard_listener_key] key=30 state=1 
    [wl_keyboard_listener_key] key=30 state=0 
    [wl_keyboard_listener_key] key=125 state=1 
    [wl_keyboard_listener_modifiers]
    [wl_keyboard_listener_leave]

Como se puede ver, nada más empezar se indica el mapa del teclado, para después indicar el tiempo de repetición en el caso de dejar pulsada una tecla. Después, se indica que la ventana tiene el foco con el evento "enter" y se van obteniendo los códigos de las teclas pulsadas o soltadas. También se puede ver el evento "modifiers" cuando se pulsa algún modificador, como pueden ser las mayúsculas.

El código con el que se ha obtenido el ejemplo es:

    // gcc -o %e %s -lwayland-client   
    
    #include <assert.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <wayland-client.h>
    #include <sys/mman.h>
    #include <xkbcommon/xkbcommon.h>
    
    #include "wayland-xdg-shell-client-protocol.h"
    
    //////////////////////////////////////////////////////////
    // Código para crear el descriptor de fichero en el que compartir la memoria
    #include <errno.h>
    #include <fcntl.h>
    #include <sys/mman.h>
    #include <unistd.h>
    
    static void
    randname(char *buf)
    {
        int r = rand();
    	for (int i = 0; i < 6; ++i) {
    		buf[i] = 'A'+(r&15)+(r&16)*2;
    		r >>= 5;
    	}
    }
    
    static int
    create_shm_file(void)
    {
    	int retries = 100;
    	do {
    		char name[] = "/wl_shm-XXXXXX";
    		randname(name + sizeof(name) - 7);
    		--retries;
    		int fd = shm_open(name, O_RDWR | O_CREAT | O_EXCL, 0600);
    		if (fd >= 0) {
    			shm_unlink(name);
    			return fd;
    		}
    	} while (retries > 0 && errno == EEXIST);
    	return -1;
    }
    
    int
    allocate_shm_file(size_t size)
    {
    	int fd = create_shm_file();
    	if (fd < 0)
    		return -1;
    	int ret;
    	do {
    		ret = ftruncate(fd, size);
    	} while (ret < 0 && errno == EINTR);
    	if (ret < 0) {
    		close(fd);
    		return -1;
    	}
    	return fd;
    }
    
    ////////////////////////////////////////////////////////////
    // Estructura de datos para almacenar recursos
    
    struct Datos {
        // Objetos para crear la memoria compartida
        struct wl_shm *shm;
        struct wl_shm_listener *shm_listener;
        uint32_t shm_format;
        uint8_t *pool_data;
        struct wl_shm_pool *pool;
        struct wl_buffer *buffer;
    
        // Objetos para crear la "surface"
        struct wl_surface *surface;
        struct wl_compositor *compositor;
        uint32_t *pixels; // Pixels de la ventana
        int n;
    
        // Objetos para crear la ventana
        struct xdg_wm_base *xdg_wm_base;
        struct xdg_wm_base_listener xdg_wm_base_listener;
        struct xdg_surface *xdg_surface;
        struct xdg_surface_listener xdg_surface_listener;
        struct wl_buffer *wl_buffer;
        struct wl_buffer_listener wl_buffer_listener;
        struct xdg_toplevel *xdg_toplevel;
        
        // Objetos para capturar el teclado
        struct wl_seat *wl_seat;
        struct wl_keyboard *wl_keyboard;
        struct wl_keyboard_listener wl_keyboard_listener;
        struct xkb_keymap *xkb_keymap;
    };
    
    
    ///////////////////////////////////////////////////////////
    // Implementación de wl_keyboard_listener
    
    static
    void wl_keyboard_listener_keymap(void *data, struct wl_keyboard *wl_keyboard,
            uint32_t format, int32_t fd, uint32_t size) {
        struct Datos *datos = (struct Datos *)data;
        assert(format == WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1);
    
        char *map_shm = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
        assert(map_shm != MAP_FAILED);
    
        //datos->xkb_keymap = xkb_keymap_new_from_string(
        //    datos->xkb_keymap, map_shm, XKB_KEYMAP_FORMAT_TEXT_V1,
        //    XKB_KEYMAP_COMPILE_NO_FLAGS);
        munmap(map_shm, size);
        close(fd);
    
        printf("[wl_keyboard_listener_keymap]\n");
    }
    
    static
    void wl_keyboard_listener_enter(void *data,
    		      struct wl_keyboard *wl_keyboard,
    		      uint32_t serial,
    		      struct wl_surface *surface,
    		      struct wl_array *keys)
    {
        struct Datos *datos = (struct Datos *)data;
        printf("[wl_keyboard_listener_enter]\n");
    }
    
    static
    void wl_keyboard_listener_leave(void *data,
    		      struct wl_keyboard *wl_keyboard,
    		      uint32_t serial,
    		      struct wl_surface *surface)
    {
        struct Datos *datos = (struct Datos *)data;
        printf("[wl_keyboard_listener_leave]\n");
    }
    
    static
    void wl_keyboard_listener_key(void *data,
    		    struct wl_keyboard *wl_keyboard,
    		    uint32_t serial,
    		    uint32_t time,
    		    uint32_t key,
    		    uint32_t state)
    {
        struct Datos *datos = (struct Datos *)data;
        printf("[wl_keyboard_listener_key] key=%d state=%d \n", key, state);
    }
    
    static
    void wl_keyboard_listener_modifiers(void *data,
    			  struct wl_keyboard *wl_keyboard,
    			  uint32_t serial,
    			  uint32_t mods_depressed,
    			  uint32_t mods_latched,
    			  uint32_t mods_locked,
    			  uint32_t group)
    {
        struct Datos *datos = (struct Datos *)data;
        printf("[wl_keyboard_listener_modifiers]\n");
    }
    
    static
    void wl_keyboard_listener_repeat_info(void *data,
    			    struct wl_keyboard *wl_keyboard,
    			    int32_t rate,
    			    int32_t delay)
    {
        struct Datos *datos = (struct Datos *)data;
        printf("[wl_keyboard_listener_repeat_info] rate=%d delay=%d\n", rate, delay);
    }
    
    ///////////////////////////////////////////////////////////
    // Metodos para capturar eventos de wl_buffer_listener
    
    static void
    wl_buffer_listener_release(void *data, struct wl_buffer *wl_buffer)
    {
        // Evento enviado por el compositor cuando el buffer no se necesita más
        wl_buffer_destroy(wl_buffer);
        printf("[wl_buffer_listener_release] Buffer destruido\n");
    }
    
    ///////////////////////////////////////////////////////////
    // Función para crear y dibujar en el buffer
    
    static struct wl_buffer *
    crear_buffer(struct Datos *datos)
    {
        // Tamaño de la ventana que se va a dibujar
        const int width = 640, height = 480;
        // Bytes por pixel
        int stride = width * 4;
        // Total de bytes de la imagen
        int size = stride * height;
    
        // Se adquiere el archivo que se usará para compartir la memoria
        int fd = allocate_shm_file(size);
        if (fd == -1) {
            return NULL;
        }
    
        // Se "mapea" para compartir
        uint32_t *data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
        if (data == MAP_FAILED) {
            close(fd);
            return NULL;
        }
        // ¡Ya se tiene el array de pixeles para dibujar!
        datos->pixels = data;
    
        // Se crea el pool para compartir la memoria con el servidor Wayland
        struct wl_shm_pool *pool = wl_shm_create_pool(datos->shm, fd, size);
        // Se crea el buffer a partir del pool
        struct wl_buffer *buffer = wl_shm_pool_create_buffer(pool, 0,
                width, height, stride, WL_SHM_FORMAT_XRGB8888);
        wl_shm_pool_destroy(pool);
        close(fd);
    
        // Se dibuja la imagen
        datos->n++;
        char par = (datos->n)%2;
        uint32_t pixel1 = par ? 0xFF666666 : 0xFFEEEEEE;
        uint32_t pixel2 = 0xFF666666;
        for (int y = 0; y < height; ++y) {
            for (int x = 0; x < width; ++x) {
                if ((x + y / 8 * 8) % 16 < 8)
                    datos->pixels[y * width + x] = pixel1;
                else
                    datos->pixels[y * width + x] = pixel2;
            }
        }
    
        munmap(data, size);
    
        // Se añade el listener a wl_buffer
        datos->wl_buffer_listener.release = wl_buffer_listener_release;
        wl_buffer_add_listener(buffer, &datos->wl_buffer_listener, datos);
        return buffer;
    }
    
    //////////////////////////////////////////////////////////
    // Metodos para capturar eventos de xdg_surface_listener
    
    void
    xdg_surface_listener_configure(void *data,
    			  struct xdg_surface *xdg_surface,
    			  uint32_t serial)
    {
        printf("[xdg_surface_listener_configure]\n");
        struct Datos *datos = (struct Datos *)data;
        xdg_surface_ack_configure(xdg_surface, serial);
    
        datos->wl_buffer = crear_buffer(datos);
        wl_surface_attach(datos->surface, datos->wl_buffer, 0, 0);
        wl_surface_damage(datos->surface, 0, 0, 640, 480);
        wl_surface_commit(datos->surface);
    }
    
    ///////////////////////////////////////////////////////////
    // Función para crear el wl_suface
    
    static void
    crear_surface(struct Datos *datos)
    {
        if(datos->xdg_surface == NULL && datos->xdg_wm_base !=NULL && datos->surface != NULL) {
            datos->xdg_surface = xdg_wm_base_get_xdg_surface(datos->xdg_wm_base, datos->surface);
            printf("xdg_surface creada\n");
            datos->xdg_surface_listener.configure = xdg_surface_listener_configure;
            xdg_surface_add_listener(datos->xdg_surface, &datos->xdg_surface_listener, datos);
            datos->xdg_toplevel = xdg_surface_get_toplevel(datos->xdg_surface);
            xdg_toplevel_set_title(datos->xdg_toplevel, "Ejemplo");
            wl_surface_commit(datos->surface);
        }
    }
    
    //////////////////////////////////////////////////////////
    // Metodos para capturar eventos de xdg_wm_base_listener
    
    static void
    xdg_wm_base_listener_ping(void *data, struct xdg_wm_base *xdg_wm_base, uint32_t serial)
    {
        //struct Datos *datos = (struct Datos*)data;
        // El cliente debe contestar al ping con un pong o se considerará que el cliente
        // no responde a los eventos
        xdg_wm_base_pong(xdg_wm_base, serial);
    }
    
    ///////////////////////////////////////////////////////////
    // Metodos para capturar eventos de shm_listener
    
    static void
    shm_listener_format(void *data, struct wl_shm *wl_shm, uint32_t format)
    {
        struct Datos *datos = (struct Datos*)data;
        datos->shm_format = format;
    }
    
    
    ////////////////////////////////////////////////////////////
    // Metodos para capturar eventos de registry_listener
    
    static void
    registry_listener_global(void *data, struct wl_registry *registry, uint32_t id,
               const char *interface, uint32_t version)
    {
        // Se obtiene la struct Datos
        struct Datos *datos = (struct Datos*) data;
    
        printf("Interface %s id %d\n", interface, id);
        
        // Se busca el recurso
        if(!strcmp(interface, "wl_shm")) {
            // Se solicita el objeto wl_shm
            datos->shm = wl_registry_bind(registry, id, &wl_shm_interface, version);
            struct wl_shm_listener *shm_listener = (struct wl_shm_listener*) malloc(sizeof(struct wl_shm_listener));
            shm_listener->format = shm_listener_format;
            datos->shm_listener = shm_listener;
        } else if(! strcmp(interface, "xdg_wm_base")) {
            datos->xdg_wm_base = wl_registry_bind(registry, id, &xdg_wm_base_interface, version);
            datos->xdg_wm_base_listener.ping = xdg_wm_base_listener_ping;
            xdg_wm_base_add_listener(datos->xdg_wm_base, &datos->xdg_wm_base_listener, datos);
            crear_surface(datos); 
        } else if(! strcmp(interface, "wl_compositor")) {
            datos->compositor = wl_registry_bind(registry, id, &wl_compositor_interface, version);
            datos->surface = wl_compositor_create_surface(datos->compositor);
            crear_surface(datos);
        } else if(! strcmp(interface, "wl_seat")) {
            datos->wl_seat = wl_registry_bind(registry, id, &wl_seat_interface, version);
            datos->wl_keyboard = wl_seat_get_keyboard(datos->wl_seat);
            wl_keyboard_add_listener(datos->wl_keyboard, &datos->wl_keyboard_listener, datos);
        }
    }
    
    static void
    registry_listener_remove(void *data, struct wl_registry *registry, uint32_t id)
    {
        printf("Se elimina el interface %d\n", id);
    }
    
    ///////////////////////////////////////////////////////////
    
    int main(int argc, char **argv)
    {
    
        struct wl_display *display = wl_display_connect(NULL);
        if (display == NULL) {
            fprintf(stderr, "No se puede conectar al display\n");
            exit(1);
        }
        printf("Conectado al display\n");
    
        // Se crea la estructura para almacenar los protocolos
        struct Datos datos;
        datos.shm = NULL;
        datos.xdg_surface = NULL;
        datos.xdg_wm_base = NULL;
        datos.surface = NULL;
        datos.wl_buffer = NULL;
        datos.n = 0;
        datos.wl_seat = NULL;
        datos.wl_keyboard = NULL;
        datos.wl_keyboard_listener.keymap = wl_keyboard_listener_keymap;
        datos.wl_keyboard_listener.enter = wl_keyboard_listener_enter;
        datos.wl_keyboard_listener.leave = wl_keyboard_listener_leave;
        datos.wl_keyboard_listener.key = wl_keyboard_listener_key;
        datos.wl_keyboard_listener.modifiers = wl_keyboard_listener_modifiers;
        datos.wl_keyboard_listener.repeat_info = wl_keyboard_listener_repeat_info;
        
    
        // Se crea el eschador de wl_registry
        struct wl_registry_listener registry_listener;
        registry_listener.global = registry_listener_global;
        registry_listener.global_remove = registry_listener_remove;
    
        // Se obtiene el objeto wl_registry 
        struct wl_registry *registry = wl_display_get_registry(display);
        // Se le añade el escuchador recién creado
        wl_registry_add_listener(registry, &registry_listener, &datos);
    
        // Se solicita que se envíen las peticiones desde el cliente al servidor
        wl_display_dispatch(display);
        // Se bloquea hasta que se procesen los eventos
        wl_display_roundtrip(display);
    
    
        while (wl_display_dispatch(display)) {
            // Bucle de eventos
        }
        
        wl_display_disconnect(display);
        printf("Desconectado del display\n");
        
        return 0;
    }


XKB
---

En el ejemplo anterior han capturado los códigos de las teclas, pero no se ha podido averiguar el carácter correspondiente a cada tecla. Para ello se puede usar XKB.

Para usar XKB se tendrá que introducir la cabecera:

    #include <xkbcommon/xkbcommon.h>

A la hora de compilar también se introducirá el correspondiente paquete con el comando:

    pkgconf --cflags --libs xkbcommon

Por ejemplo, para compilar con gcc:

    gcc -o xdg-shell *.c -lwayland-client -lrt `pkgconf --cflags --libs xkbcommon`

Se tiene que trabajar con 3 objetos para manejar XKB:
 - xkb_context: Se usa para poder configurar los recursos de XKB. Para iniciarlo se usará:

    struct xkb_context *context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);

 - xkb_keymap: Se usa para obtener los mapas. Este objeto se obtendrá a partir del evento keymap de wl_keyboard_listener que genera Wayland. Por ejemplo:

    static
    void wl_keyboard_listener_keymap(void *data, struct wl_keyboard *wl_keyboard,
            uint32_t format, int32_t fd, uint32_t size) {
        struct Datos *datos = (struct Datos *)data;
        assert(format == WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1);
    
        char *map_shm = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
        assert(map_shm != MAP_FAILED);
    
        datos->xkb_keymap = xkb_keymap_new_from_string(
            datos->xkb_context, map_shm, XKB_KEYMAP_FORMAT_TEXT_V1,
            XKB_KEYMAP_COMPILE_NO_FLAGS);
        munmap(map_shm, size);
        close(fd);
    
        datos->xkb_state = xkb_state_new(datos->xkb_keymap);
        printf("[wl_keyboard_listener_keymap]\n");
    }

 - xkb_state: Para poder generar ciertos símbolos correctamente se necesita guardar un estado de las teclas pulsadas previamente. Por ejemplo, para escribir una A mayúscula, se deberá haber guardado el estado de la tecla mayúscula pulsada. Se debe inicializar con "xkb_state_new" como se puede ver en el ejemplo de xkb_keymap. Para almacenar el estado se usará "xkb_state_update_mask". Esto se debe usar en el evento "modifiers":

    static
    void wl_keyboard_listener_modifiers(void *data,
    			  struct wl_keyboard *wl_keyboard,
    			  uint32_t serial,
    			  uint32_t mods_depressed,
    			  uint32_t mods_latched,
    			  uint32_t mods_locked,
    			  uint32_t group)
    {
        struct Datos *datos = (struct Datos *)data;
        printf("[wl_keyboard_listener_modifiers]\n");
        xkb_state_update_mask(datos->xkb_state,
            mods_depressed, mods_latched, mods_locked, 0, 0, group);
    }

Por último, para poder trabajar con los mapas de teclado correctamente, se sumará 8 al código de la tecla que se obtiene del evento "key" de wl_keyboard_listener. Por ejemplo:

    static
    void wl_keyboard_listener_key(void *data,
    		    struct wl_keyboard *wl_keyboard,
    		    uint32_t serial,
    		    uint32_t time,
    		    uint32_t key,
    		    uint32_t state)
    {
        struct Datos *datos = (struct Datos *)data;
        printf("[wl_keyboard_listener_key] key=%d state=%d \n", key, state);
        // Para que xkb interprete bien las teclas hay que sumar 8 al valor
        // dado por evdev:
        key += 8;
        // Se puede trabajar directamente con los códigos que se asocian 
        // a las teclas. Los códigos se pueden encontrar en:
        // xkbcommon/xkbcommon-keysyms.h
        xkb_keysym_t sym = xkb_state_key_get_one_sym(datos->xkb_state, key);
        if (sym == XKB_KEY_F1) {
            // Hacer algo cuando se pulsa F1
        }
        
        // Se puede convertir cada tecla en su símbolo correspondiente:
        char buf[128];
        xkb_state_key_get_utf8(datos->xkb_state, key, buf, sizeof(buf));
        printf("UTF-8 input: %s\n", buf);
    }

Como se puede ver en el código anterior, se puede trabajar de dos formas con los símbolos del teclado:
 - Usando los valores definidos en la cabecera "xkbcommon/xkbcommon-keysyms.h". En esta cabecera se define un valor para cada símbolo o tecla y se puede trabajar directamente con dicho valor:

        xkb_keysym_t sym = xkb_state_key_get_one_sym(datos->xkb_state, key);
        if (sym == XKB_KEY_F1) {
            // Hacer algo cuando se pulsa F1
        }

 - Usando la cadena de caracteres asociado. Por ejemplo:

        // Se puede convertir cada tecla en su símbolo correspondiente:
        char buf[128];
        xkb_state_key_get_utf8(datos->xkb_state, key, buf, sizeof(buf));
        printf("UTF-8 input: %s\n", buf);

El uso de uno u otro dependerá de lo que se quiera hacer.

El ejemplo completo de uso del teclado se tiene aquí:

    // gcc -o %e %s -lwayland-client -lrt `pkgconf --cflags --libs xkbcommon`

    
    #include <assert.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <wayland-client.h>
    #include <sys/mman.h>
    #include <xkbcommon/xkbcommon.h>
    
    #include "wayland-xdg-shell-client-protocol.h"
    
    //////////////////////////////////////////////////////////
    // Código para crear el descriptor de fichero en el que compartir la memoria
    #include <errno.h>
    #include <fcntl.h>
    #include <sys/mman.h>
    #include <unistd.h>
    
    static void
    randname(char *buf)
    {
        int r = rand();
    	for (int i = 0; i < 6; ++i) {
    		buf[i] = 'A'+(r&15)+(r&16)*2;
    		r >>= 5;
    	}
    }
    
    static int
    create_shm_file(void)
    {
    	int retries = 100;
    	do {
    		char name[] = "/wl_shm-XXXXXX";
    		randname(name + sizeof(name) - 7);
    		--retries;
    		int fd = shm_open(name, O_RDWR | O_CREAT | O_EXCL, 0600);
    		if (fd >= 0) {
    			shm_unlink(name);
    			return fd;
    		}
    	} while (retries > 0 && errno == EEXIST);
    	return -1;
    }
    
    int
    allocate_shm_file(size_t size)
    {
    	int fd = create_shm_file();
    	if (fd < 0)
    		return -1;
    	int ret;
    	do {
    		ret = ftruncate(fd, size);
    	} while (ret < 0 && errno == EINTR);
    	if (ret < 0) {
    		close(fd);
    		return -1;
    	}
    	return fd;
    }
    
    ////////////////////////////////////////////////////////////
    // Estructura de datos para almacenar recursos
    
    struct Datos {
        // Objetos para crear la memoria compartida
        struct wl_shm *shm;
        struct wl_shm_listener *shm_listener;
        uint32_t shm_format;
        uint8_t *pool_data;
        struct wl_shm_pool *pool;
        struct wl_buffer *buffer;
    
        // Objetos para crear la "surface"
        struct wl_surface *surface;
        struct wl_compositor *compositor;
        uint32_t *pixels; // Pixels de la ventana
        int n;
    
        // Objetos para crear la ventana
        struct xdg_wm_base *xdg_wm_base;
        struct xdg_wm_base_listener xdg_wm_base_listener;
        struct xdg_surface *xdg_surface;
        struct xdg_surface_listener xdg_surface_listener;
        struct wl_buffer *wl_buffer;
        struct wl_buffer_listener wl_buffer_listener;
        struct xdg_toplevel *xdg_toplevel;
        
        // Objetos para capturar el teclado
        struct wl_seat *wl_seat;
        struct wl_keyboard *wl_keyboard;
        struct wl_keyboard_listener wl_keyboard_listener;
        struct xkb_keymap *xkb_keymap;
        struct xkb_context *xkb_context;
        struct xkb_state *xkb_state;
    };
    
    
    ///////////////////////////////////////////////////////////
    // Implementación de wl_keyboard_listener
    
    static
    void wl_keyboard_listener_keymap(void *data, struct wl_keyboard *wl_keyboard,
            uint32_t format, int32_t fd, uint32_t size) {
        struct Datos *datos = (struct Datos *)data;
        assert(format == WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1);
    
        char *map_shm = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
        assert(map_shm != MAP_FAILED);
    
        datos->xkb_keymap = xkb_keymap_new_from_string(
            datos->xkb_context, map_shm, XKB_KEYMAP_FORMAT_TEXT_V1,
            XKB_KEYMAP_COMPILE_NO_FLAGS);
        munmap(map_shm, size);
        close(fd);
    
        datos->xkb_state = xkb_state_new(datos->xkb_keymap);
        printf("[wl_keyboard_listener_keymap]\n");
    }
    
    static
    void wl_keyboard_listener_enter(void *data,
    		      struct wl_keyboard *wl_keyboard,
    		      uint32_t serial,
    		      struct wl_surface *surface,
    		      struct wl_array *keys)
    {
        struct Datos *datos = (struct Datos *)data;
        printf("[wl_keyboard_listener_enter]\n");
    }
    
    static
    void wl_keyboard_listener_leave(void *data,
    		      struct wl_keyboard *wl_keyboard,
    		      uint32_t serial,
    		      struct wl_surface *surface)
    {
        struct Datos *datos = (struct Datos *)data;
        printf("[wl_keyboard_listener_leave]\n");
    }
    
    static
    void wl_keyboard_listener_key(void *data,
    		    struct wl_keyboard *wl_keyboard,
    		    uint32_t serial,
    		    uint32_t time,
    		    uint32_t key,
    		    uint32_t state)
    {
        struct Datos *datos = (struct Datos *)data;
        printf("[wl_keyboard_listener_key] key=%d state=%d \n", key, state);
        // Para que xkb interprete bien las teclas hay que sumar 8 al valor
        // dado por evdev:
        key += 8;
        // Se puede trabajar directamente con los códigos que se asocian 
        // a las teclas. Los códigos se pueden encontrar en:
        // xkbcommon/xkbcommon-keysyms.h
        xkb_keysym_t sym = xkb_state_key_get_one_sym(datos->xkb_state, key);
        if (sym == XKB_KEY_F1) {
            // Hacer algo cuando se pulsa F1
        }
        
        // Se puede convertir cada tecla en su símbolo correspondiente:
        char buf[128];
        xkb_state_key_get_utf8(datos->xkb_state, key, buf, sizeof(buf));
        printf("UTF-8 input: %s\n", buf);
    }
    
    static
    void wl_keyboard_listener_modifiers(void *data,
    			  struct wl_keyboard *wl_keyboard,
    			  uint32_t serial,
    			  uint32_t mods_depressed,
    			  uint32_t mods_latched,
    			  uint32_t mods_locked,
    			  uint32_t group)
    {
        struct Datos *datos = (struct Datos *)data;
        printf("[wl_keyboard_listener_modifiers]\n");
        xkb_state_update_mask(datos->xkb_state,
            mods_depressed, mods_latched, mods_locked, 0, 0, group);
    }
    
    static
    void wl_keyboard_listener_repeat_info(void *data,
    			    struct wl_keyboard *wl_keyboard,
    			    int32_t rate,
    			    int32_t delay)
    {
        struct Datos *datos = (struct Datos *)data;
        printf("[wl_keyboard_listener_repeat_info] rate=%d delay=%d\n", rate, delay);
    }
    
    ///////////////////////////////////////////////////////////
    // Metodos para capturar eventos de wl_buffer_listener
    
    static void
    wl_buffer_listener_release(void *data, struct wl_buffer *wl_buffer)
    {
        // Evento enviado por el compositor cuando el buffer no se necesita más
        wl_buffer_destroy(wl_buffer);
        printf("[wl_buffer_listener_release] Buffer destruido\n");
    }
    
    ///////////////////////////////////////////////////////////
    // Función para crear y dibujar en el buffer
    
    static struct wl_buffer *
    crear_buffer(struct Datos *datos)
    {
        // Tamaño de la ventana que se va a dibujar
        const int width = 640, height = 480;
        // Bytes por pixel
        int stride = width * 4;
        // Total de bytes de la imagen
        int size = stride * height;
    
        // Se adquiere el archivo que se usará para compartir la memoria
        int fd = allocate_shm_file(size);
        if (fd == -1) {
            return NULL;
        }
    
        // Se "mapea" para compartir
        uint32_t *data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
        if (data == MAP_FAILED) {
            close(fd);
            return NULL;
        }
        // ¡Ya se tiene el array de pixeles para dibujar!
        datos->pixels = data;
    
        // Se crea el pool para compartir la memoria con el servidor Wayland
        struct wl_shm_pool *pool = wl_shm_create_pool(datos->shm, fd, size);
        // Se crea el buffer a partir del pool
        struct wl_buffer *buffer = wl_shm_pool_create_buffer(pool, 0,
                width, height, stride, WL_SHM_FORMAT_XRGB8888);
        wl_shm_pool_destroy(pool);
        close(fd);
    
        // Se dibuja la imagen
        datos->n++;
        char par = (datos->n)%2;
        uint32_t pixel1 = par ? 0xFF666666 : 0xFFEEEEEE;
        uint32_t pixel2 = 0xFF666666;
        for (int y = 0; y < height; ++y) {
            for (int x = 0; x < width; ++x) {
                if ((x + y / 8 * 8) % 16 < 8)
                    datos->pixels[y * width + x] = pixel1;
                else
                    datos->pixels[y * width + x] = pixel2;
            }
        }
    
        munmap(data, size);
    
        // Se añade el listener a wl_buffer
        datos->wl_buffer_listener.release = wl_buffer_listener_release;
        wl_buffer_add_listener(buffer, &datos->wl_buffer_listener, datos);
        return buffer;
    }
    
    //////////////////////////////////////////////////////////
    // Metodos para capturar eventos de xdg_surface_listener
    
    void
    xdg_surface_listener_configure(void *data,
    			  struct xdg_surface *xdg_surface,
    			  uint32_t serial)
    {
        printf("[xdg_surface_listener_configure]\n");
        struct Datos *datos = (struct Datos *)data;
        xdg_surface_ack_configure(xdg_surface, serial);
    
        datos->wl_buffer = crear_buffer(datos);
        wl_surface_attach(datos->surface, datos->wl_buffer, 0, 0);
        wl_surface_damage(datos->surface, 0, 0, 640, 480);
        wl_surface_commit(datos->surface);
    }
    
    ///////////////////////////////////////////////////////////
    // Función para crear el wl_suface
    
    static void
    crear_surface(struct Datos *datos)
    {
        if(datos->xdg_surface == NULL && datos->xdg_wm_base !=NULL && datos->surface != NULL) {
            datos->xdg_surface = xdg_wm_base_get_xdg_surface(datos->xdg_wm_base, datos->surface);
            printf("xdg_surface creada\n");
            datos->xdg_surface_listener.configure = xdg_surface_listener_configure;
            xdg_surface_add_listener(datos->xdg_surface, &datos->xdg_surface_listener, datos);
            datos->xdg_toplevel = xdg_surface_get_toplevel(datos->xdg_surface);
            xdg_toplevel_set_title(datos->xdg_toplevel, "Ejemplo");
            wl_surface_commit(datos->surface);
        }
    }
    
    //////////////////////////////////////////////////////////
    // Metodos para capturar eventos de xdg_wm_base_listener
    
    static void
    xdg_wm_base_listener_ping(void *data, struct xdg_wm_base *xdg_wm_base, uint32_t serial)
    {
        //struct Datos *datos = (struct Datos*)data;
        // El cliente debe contestar al ping con un pong o se considerará que el cliente
        // no responde a los eventos
        xdg_wm_base_pong(xdg_wm_base, serial);
    }
    
    ///////////////////////////////////////////////////////////
    // Metodos para capturar eventos de shm_listener
    
    static void
    shm_listener_format(void *data, struct wl_shm *wl_shm, uint32_t format)
    {
        struct Datos *datos = (struct Datos*)data;
        datos->shm_format = format;
    }
    
    
    ////////////////////////////////////////////////////////////
    // Metodos para capturar eventos de registry_listener
    
    static void
    registry_listener_global(void *data, struct wl_registry *registry, uint32_t id,
               const char *interface, uint32_t version)
    {
        // Se obtiene la struct Datos
        struct Datos *datos = (struct Datos*) data;
    
        printf("Interface %s id %d\n", interface, id);
        
        // Se busca el recurso
        if(!strcmp(interface, "wl_shm")) {
            // Se solicita el objeto wl_shm
            datos->shm = wl_registry_bind(registry, id, &wl_shm_interface, version);
            struct wl_shm_listener *shm_listener = (struct wl_shm_listener*) malloc(sizeof(struct wl_shm_listener));
            shm_listener->format = shm_listener_format;
            datos->shm_listener = shm_listener;
        } else if(! strcmp(interface, "xdg_wm_base")) {
            datos->xdg_wm_base = wl_registry_bind(registry, id, &xdg_wm_base_interface, version);
            datos->xdg_wm_base_listener.ping = xdg_wm_base_listener_ping;
            xdg_wm_base_add_listener(datos->xdg_wm_base, &datos->xdg_wm_base_listener, datos);
            crear_surface(datos); 
        } else if(! strcmp(interface, "wl_compositor")) {
            datos->compositor = wl_registry_bind(registry, id, &wl_compositor_interface, version);
            datos->surface = wl_compositor_create_surface(datos->compositor);
            crear_surface(datos);
        } else if(! strcmp(interface, "wl_seat")) {
            datos->wl_seat = wl_registry_bind(registry, id, &wl_seat_interface, version);
            datos->wl_keyboard = wl_seat_get_keyboard(datos->wl_seat);
            wl_keyboard_add_listener(datos->wl_keyboard, &datos->wl_keyboard_listener, datos);
        }
    }
    
    static void
    registry_listener_remove(void *data, struct wl_registry *registry, uint32_t id)
    {
        printf("Se elimina el interface %d\n", id);
    }
    
    ///////////////////////////////////////////////////////////
    
    int main(int argc, char **argv)
    {
    
        struct wl_display *display = wl_display_connect(NULL);
        if (display == NULL) {
            fprintf(stderr, "No se puede conectar al display\n");
            exit(1);
        }
        printf("Conectado al display\n");
    
        // Se crea la estructura para almacenar los protocolos
        struct Datos datos;
        datos.shm = NULL;
        datos.xdg_surface = NULL;
        datos.xdg_wm_base = NULL;
        datos.surface = NULL;
        datos.wl_buffer = NULL;
        datos.n = 0;
        datos.wl_seat = NULL;
        datos.wl_keyboard = NULL;
        datos.wl_keyboard_listener.keymap = wl_keyboard_listener_keymap;
        datos.wl_keyboard_listener.enter = wl_keyboard_listener_enter;
        datos.wl_keyboard_listener.leave = wl_keyboard_listener_leave;
        datos.wl_keyboard_listener.key = wl_keyboard_listener_key;
        datos.wl_keyboard_listener.modifiers = wl_keyboard_listener_modifiers;
        datos.wl_keyboard_listener.repeat_info = wl_keyboard_listener_repeat_info;
        datos.xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
    
        // Se crea el eschador de wl_registry
        struct wl_registry_listener registry_listener;
        registry_listener.global = registry_listener_global;
        registry_listener.global_remove = registry_listener_remove;
    
        // Se obtiene el objeto wl_registry 
        struct wl_registry *registry = wl_display_get_registry(display);
        // Se le añade el escuchador recién creado
        wl_registry_add_listener(registry, &registry_listener, &datos);
    
        // Se solicita que se envíen las peticiones desde el cliente al servidor
        wl_display_dispatch(display);
        // Se bloquea hasta que se procesen los eventos
        wl_display_roundtrip(display);
    
    
        while (wl_display_dispatch(display)) {
            // Bucle de eventos
        }
        
        wl_display_disconnect(display);
        printf("Desconectado del display\n");
        
        return 0;
    }
